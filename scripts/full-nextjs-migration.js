#!/usr/bin/env node

/**
 * ÂÆåÊï¥ÁöÑ Next.js ËøÅÁßªËÑöÊú¨
 * ‰øùÁïôÊâÄÊúâÂéüÊúâÂäüËÉΩÔºåÂàõÂª∫‰∏Ä‰∏™ÂÆåÊï¥ÁöÑ Next.js ÁâàÊú¨
 */

import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

console.log('üöÄ ÂºÄÂßãÂÆåÊï¥ÁöÑ Next.js ËøÅÁßª...\n');

/**
 * Ê≠•È™§ 1: ÂàõÂª∫Â§á‰ªΩ
 */
async function createBackup() {
  console.log('üì¶ ÂàõÂª∫È°πÁõÆÂ§á‰ªΩ...');
  const backupDir = path.join(projectRoot, 'backup-vite');
  
  // Â§á‰ªΩÂÖ≥ÈîÆÊñá‰ª∂
  const filesToBackup = [
    'package.json',
    'vite.config.js', 
    'src/App.jsx',
    'src/main.jsx',
    'index.html'
  ];
  
  try {
    await fs.mkdir(backupDir, { recursive: true });
    
    for (const file of filesToBackup) {
      const srcPath = path.join(projectRoot, file);
      const destPath = path.join(backupDir, file);
      
      try {
        const content = await fs.readFile(srcPath, 'utf8');
        await fs.mkdir(path.dirname(destPath), { recursive: true });
        await fs.writeFile(destPath, content, 'utf8');
        console.log(`   ‚úÖ Â§á‰ªΩ: ${file}`);
      } catch (err) {
        console.log(`   ‚ö†Ô∏è  Ë∑≥Ëøá: ${file} (Êñá‰ª∂‰∏çÂ≠òÂú®)`);
      }
    }
    
    // Â§á‰ªΩÊï¥‰∏™ src ÁõÆÂΩï
    console.log('   üìÅ Â§á‰ªΩ src ÁõÆÂΩï...');
    await copyDirectory(path.join(projectRoot, 'src'), path.join(backupDir, 'src'));
    
    console.log('‚úÖ Â§á‰ªΩÂÆåÊàê\n');
  } catch (error) {
    console.error('‚ùå Â§á‰ªΩÂ§±Ë¥•:', error);
    throw error;
  }
}

/**
 * Ê≠•È™§ 2: Êõ¥Êñ∞ package.json
 */
async function updatePackageJson() {
  console.log('üìù Êõ¥Êñ∞ package.json...');
  
  const packageJsonPath = path.join(projectRoot, 'package.json');
  const currentPackage = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
  
  // Êñ∞ÁöÑ package.json ÈÖçÁΩÆ
  const newPackage = {
    ...currentPackage,
    name: "meownocode-nextjs",
    version: "2.0.0",
    description: "MeowNocode - ÂÆåÊï¥ÁöÑ Next.js ÁâàÊú¨ÔºåÊîØÊåÅË∑®ÊµèËßàÂô®Êï∞ÊçÆÂÖ±‰∫´",
    scripts: {
      // Next.js ËÑöÊú¨
      "dev": "next dev -p 3001",
      "build": "next build", 
      "start": "next start -p 3001",
      "lint": "next lint",
      "export": "next export",
      
      // Êï∞ÊçÆÂ∫ìËÑöÊú¨
      "db:init": "node scripts/init-db.js",
      "db:migrate": "node scripts/migrate-data.js",
      "db:backup": "node scripts/backup-db.js", 
      "db:reset": "node scripts/reset-db.js",
      
      // ËøÅÁßªËÑöÊú¨
      "migrate:data": "node scripts/migrate-browser-data.js",
      "full-migration": "node scripts/full-nextjs-migration.js",
      
      // ÂºÄÂèëËÑöÊú¨
      "dev:both": "concurrently \"npm run dev:vite\" \"npm run dev\"",
      "dev:vite": "vite --port 8080",
      
      // ‰øùÊåÅÂéüÊúâÁöÑÊûÑÂª∫ËÑöÊú¨‰Ωú‰∏∫Â§á‰ªΩ
      "build:vite": "vite build",
      "preview:vite": "vite preview"
    },
    dependencies: {
      // Next.js Ê†∏ÂøÉ
      "next": "14.2.32",
      "react": "^18.2.0", 
      "react-dom": "^18.2.0",
      
      // Êï∞ÊçÆÂ∫ì
      "sqlite3": "^5.1.6",
      "better-sqlite3": "^9.4.0",
      
      // ‰øùÊåÅÊâÄÊúâÁé∞Êúâ‰æùËµñ
      ...currentPackage.dependencies,
      
      // ÁßªÈô§ Vite ÁâπÂÆö‰æùËµñÔºå‰ΩÜ‰øùÁïô sql.js Á≠âÈÄöÁî®Â∫ì
    },
    devDependencies: {
      // Next.js ÂºÄÂèë‰æùËµñ
      "@types/node": "^20",
      "@types/react": "^18.2.43",
      "@types/react-dom": "^18.2.17",
      "eslint": "^8",
      "eslint-config-next": "14.2.32",
      
      // ‰øùÊåÅÁé∞ÊúâÂºÄÂèë‰æùËµñ
      ...currentPackage.devDependencies,
      
      // Â∑•ÂÖ∑
      "concurrently": "^8.2.2"
    }
  };
  
  await fs.writeFile(packageJsonPath, JSON.stringify(newPackage, null, 2));
  console.log('‚úÖ package.json Êõ¥Êñ∞ÂÆåÊàê\n');
}

/**
 * Ê≠•È™§ 3: ÂàõÂª∫ Next.js ÈÖçÁΩÆ
 */
async function createNextConfig() {
  console.log('‚öôÔ∏è ÂàõÂª∫ Next.js ÈÖçÁΩÆ...');
  
  const nextConfigContent = `/** @type {import('next').NextConfig} */
const nextConfig = {
  // ÂÆûÈ™åÊÄßÈÖçÁΩÆ
  experimental: {
    serverComponentsExternalPackages: ['sqlite3', 'better-sqlite3', 'sql.js']
  },
  
  // ÊîØÊåÅ ESM
  typescript: {
    ignoreBuildErrors: false,
  },
  eslint: {
    ignoreDuringBuilds: false,
  },
  
  // ÂºÄÂèëÊúçÂä°Âô®ÈÖçÁΩÆ
  async redirects() {
    return [];
  },
  
  // Webpack ÈÖçÁΩÆ
  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
    // ÊîØÊåÅ WASM Êñá‰ª∂
    config.experiments = {
      ...config.experiments,
      asyncWebAssembly: true,
      layers: true,
    };
    
    // Â§ÑÁêÜ sql.js ÁöÑ WASM Êñá‰ª∂
    config.module.rules.push({
      test: /\\.wasm$/,
      type: 'webassembly/async',
    });
    
    // Â§ñÈÉ®ÂåñÊúçÂä°Âô®Á´ØÁöÑÊï∞ÊçÆÂ∫ìÈ©±Âä®
    if (isServer) {
      config.externals.push('sqlite3', 'better-sqlite3');
    }
    
    return config;
  },
  
  // ÈùôÊÄÅËµÑÊ∫êÈÖçÁΩÆ
  assetPrefix: '',
  
  // ‰ºòÂåñÈÖçÁΩÆ
  swcMinify: true,
  
  // ÂõæÁâá‰ºòÂåñ
  images: {
    domains: [],
    formats: ['image/webp', 'image/avif'],
  },
};

export default nextConfig;
`;
  
  await fs.writeFile(path.join(projectRoot, 'next.config.js'), nextConfigContent);
  console.log('‚úÖ Next.js ÈÖçÁΩÆÂàõÂª∫ÂÆåÊàê\n');
}

/**
 * Ê≠•È™§ 4: ÂàõÂª∫ Next.js ÁõÆÂΩïÁªìÊûÑ
 */
async function createNextDirectories() {
  console.log('üìÅ ÂàõÂª∫ Next.js ÁõÆÂΩïÁªìÊûÑ...');
  
  const directories = [
    'pages',
    'pages/api',
    'pages/api/memos',
    'pages/api/attachments',
    'pages/api/auth',
    'pages/api/settings',
    'pages/api/import',
    'pages/api/export',
    'lib/server',
    'lib/client',
    'components/nextjs',
    'public/uploads',
    'scripts'
  ];
  
  for (const dir of directories) {
    await fs.mkdir(path.join(projectRoot, dir), { recursive: true });
    console.log(`   üìÇ ÂàõÂª∫ÁõÆÂΩï: ${dir}`);
  }
  
  console.log('‚úÖ ÁõÆÂΩïÁªìÊûÑÂàõÂª∫ÂÆåÊàê\n');
}

/**
 * Ê≠•È™§ 5: ÂàõÂª∫ÊúçÂä°Âô®Á´ØÊï∞ÊçÆÂ∫ìÊúçÂä°
 */
async function createServerServices() {
  console.log('üóÑÔ∏è ÂàõÂª∫ÊúçÂä°Âô®Á´ØÊúçÂä°...');
  
  // Êï∞ÊçÆÂ∫ìËøûÊé•
  const databaseContent = `import Database from 'better-sqlite3';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class DatabaseService {
  constructor() {
    this.db = null;
    this.init();
  }
  
  init() {
    try {
      const dbPath = path.join(process.cwd(), 'data', 'meownocode.db');
      this.db = new Database(dbPath);
      
      // ÂàõÂª∫Ë°®
      this.createTables();
      
      console.log('‚úÖ Êï∞ÊçÆÂ∫ìËøûÊé•ÊàêÂäü');
    } catch (error) {
      console.error('‚ùå Êï∞ÊçÆÂ∫ìËøûÊé•Â§±Ë¥•:', error);
      throw error;
    }
  }
  
  createTables() {
    const createMemosTable = \`
      CREATE TABLE IF NOT EXISTS memos (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        content TEXT NOT NULL,
        tags TEXT,
        visibility TEXT DEFAULT 'private',
        pinned BOOLEAN DEFAULT 0,
        created_ts DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_ts DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    \`;
    
    const createResourcesTable = \`
      CREATE TABLE IF NOT EXISTS resources (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        memo_id INTEGER,
        filename TEXT NOT NULL,
        type TEXT,
        size INTEGER,
        blob BLOB,
        created_ts DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (memo_id) REFERENCES memos (id) ON DELETE CASCADE
      )
    \`;
    
    const createSettingsTable = \`
      CREATE TABLE IF NOT EXISTS settings (
        key TEXT PRIMARY KEY,
        value TEXT,
        updated_ts DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    \`;
    
    this.db.exec(createMemosTable);
    this.db.exec(createResourcesTable);
    this.db.exec(createSettingsTable);
  }
  
  // Memos Êìç‰Ωú
  getAllMemos() {
    return this.db.prepare(\`
      SELECT * FROM memos 
      ORDER BY pinned DESC, created_ts DESC
    \`).all();
  }
  
  getMemoById(id) {
    return this.db.prepare('SELECT * FROM memos WHERE id = ?').get(id);
  }
  
  createMemo(data) {
    const { content, tags = '', visibility = 'private', pinned = false } = data;
    const result = this.db.prepare(\`
      INSERT INTO memos (content, tags, visibility, pinned)
      VALUES (?, ?, ?, ?)
    \`).run(content, tags, visibility, pinned ? 1 : 0);
    
    return this.getMemoById(result.lastInsertRowid);
  }
  
  updateMemo(id, data) {
    const { content, tags, visibility, pinned } = data;
    this.db.prepare(\`
      UPDATE memos 
      SET content = ?, tags = ?, visibility = ?, pinned = ?, updated_ts = CURRENT_TIMESTAMP
      WHERE id = ?
    \`).run(content, tags, visibility, pinned ? 1 : 0, id);
    
    return this.getMemoById(id);
  }
  
  deleteMemo(id) {
    const result = this.db.prepare('DELETE FROM memos WHERE id = ?').run(id);
    return result.changes > 0;
  }
  
  // Resources Êìç‰Ωú
  getResourcesByMemoId(memoId) {
    return this.db.prepare('SELECT * FROM resources WHERE memo_id = ?').all(memoId);
  }
  
  createResource(data) {
    const { memo_id, filename, type, size, blob } = data;
    const result = this.db.prepare(\`
      INSERT INTO resources (memo_id, filename, type, size, blob)
      VALUES (?, ?, ?, ?, ?)
    \`).run(memo_id, filename, type, size, blob);
    
    return result.lastInsertRowid;
  }
  
  // Settings Êìç‰Ωú
  getSetting(key) {
    const result = this.db.prepare('SELECT value FROM settings WHERE key = ?').get(key);
    return result ? result.value : null;
  }
  
  setSetting(key, value) {
    this.db.prepare(\`
      INSERT OR REPLACE INTO settings (key, value, updated_ts)
      VALUES (?, ?, CURRENT_TIMESTAMP)
    \`).run(key, value);
  }
  
  close() {
    if (this.db) {
      this.db.close();
    }
  }
}

// Âçï‰æãÊ®°Âºè
let dbInstance = null;

export function getDatabase() {
  if (!dbInstance) {
    dbInstance = new DatabaseService();
  }
  return dbInstance;
}

export default getDatabase;
`;
  
  await fs.writeFile(path.join(projectRoot, 'lib/server/database.js'), databaseContent);
  console.log('   ‚úÖ Êï∞ÊçÆÂ∫ìÊúçÂä°ÂàõÂª∫ÂÆåÊàê');
  
  // API ‰∏≠Èó¥‰ª∂
  const middlewareContent = `export function withMethods(allowedMethods) {
  return function (handler) {
    return async function (req, res) {
      if (!allowedMethods.includes(req.method)) {
        res.setHeader('Allow', allowedMethods.join(', '));
        return res.status(405).json({ error: 'Method Not Allowed' });
      }
      
      try {
        await handler(req, res);
      } catch (error) {
        console.error('API Error:', error);
        res.status(500).json({ error: 'Internal Server Error' });
      }
    };
  };
}

export function withCors(handler) {
  return async function (req, res) {
    // ËÆæÁΩÆ CORS Â§¥
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    
    // Â§ÑÁêÜÈ¢ÑÊ£ÄËØ∑Ê±Ç
    if (req.method === 'OPTIONS') {
      return res.status(200).end();
    }
    
    return handler(req, res);
  };
}
`;
  
  await fs.writeFile(path.join(projectRoot, 'lib/server/middleware.js'), middlewareContent);
  console.log('   ‚úÖ API ‰∏≠Èó¥‰ª∂ÂàõÂª∫ÂÆåÊàê');
  
  console.log('‚úÖ ÊúçÂä°Âô®Á´ØÊúçÂä°ÂàõÂª∫ÂÆåÊàê\n');
}

/**
 * Ê≠•È™§ 6: ÂàõÂª∫ API Routes
 */
async function createApiRoutes() {
  console.log('üõ†Ô∏è ÂàõÂª∫ API Routes...');
  
  // Memos API
  const memosApiContent = `import { getDatabase } from '../../lib/server/database.js';
import { withMethods, withCors } from '../../lib/server/middleware.js';

async function handler(req, res) {
  const db = getDatabase();
  
  switch (req.method) {
    case 'GET':
      try {
        const memos = db.getAllMemos();
        res.status(200).json({ memos });
      } catch (error) {
        console.error('Ëé∑Âèñ memos Â§±Ë¥•:', error);
        res.status(500).json({ error: 'Ëé∑Âèñ memos Â§±Ë¥•' });
      }
      break;
      
    case 'POST':
      try {
        const memo = db.createMemo(req.body);
        res.status(201).json({ memo });
      } catch (error) {
        console.error('ÂàõÂª∫ memo Â§±Ë¥•:', error);
        res.status(500).json({ error: 'ÂàõÂª∫ memo Â§±Ë¥•' });
      }
      break;
      
    default:
      res.setHeader('Allow', ['GET', 'POST']);
      res.status(405).json({ error: 'Method Not Allowed' });
  }
}

export default withCors(withMethods(['GET', 'POST'])(handler));
`;
  
  await fs.writeFile(path.join(projectRoot, 'pages/api/memos/index.js'), memosApiContent);
  
  // Âçï‰∏™ Memo API
  const memoByIdContent = `import { getDatabase } from '../../../lib/server/database.js';
import { withMethods, withCors } from '../../../lib/server/middleware.js';

async function handler(req, res) {
  const { id } = req.query;
  const db = getDatabase();
  
  switch (req.method) {
    case 'GET':
      try {
        const memo = db.getMemoById(id);
        if (!memo) {
          return res.status(404).json({ error: 'Memo ‰∏çÂ≠òÂú®' });
        }
        res.status(200).json({ memo });
      } catch (error) {
        console.error('Ëé∑Âèñ memo Â§±Ë¥•:', error);
        res.status(500).json({ error: 'Ëé∑Âèñ memo Â§±Ë¥•' });
      }
      break;
      
    case 'PUT':
      try {
        const memo = db.updateMemo(id, req.body);
        if (!memo) {
          return res.status(404).json({ error: 'Memo ‰∏çÂ≠òÂú®' });
        }
        res.status(200).json({ memo });
      } catch (error) {
        console.error('Êõ¥Êñ∞ memo Â§±Ë¥•:', error);
        res.status(500).json({ error: 'Êõ¥Êñ∞ memo Â§±Ë¥•' });
      }
      break;
      
    case 'DELETE':
      try {
        const success = db.deleteMemo(id);
        if (!success) {
          return res.status(404).json({ error: 'Memo ‰∏çÂ≠òÂú®' });
        }
        res.status(200).json({ message: 'Âà†Èô§ÊàêÂäü' });
      } catch (error) {
        console.error('Âà†Èô§ memo Â§±Ë¥•:', error);
        res.status(500).json({ error: 'Âà†Èô§ memo Â§±Ë¥•' });
      }
      break;
      
    default:
      res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
      res.status(405).json({ error: 'Method Not Allowed' });
  }
}

export default withCors(withMethods(['GET', 'PUT', 'DELETE'])(handler));
`;
  
  await fs.writeFile(path.join(projectRoot, 'pages/api/memos/[id].js'), memoByIdContent);
  
  // Health Check API
  const healthContent = `export default function handler(req, res) {
  res.status(200).json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    version: '2.0.0'
  });
}
`;
  
  await fs.writeFile(path.join(projectRoot, 'pages/api/health.js'), healthContent);
  
  console.log('‚úÖ API Routes ÂàõÂª∫ÂÆåÊàê\n');
}

/**
 * Ê≠•È™§ 7: ÂàõÂª∫ÂÆ¢Êà∑Á´ØÊúçÂä°
 */
async function createClientServices() {
  console.log('üíª ÂàõÂª∫ÂÆ¢Êà∑Á´ØÊúçÂä°...');
  
  const clientApiContent = `class NextApiClient {
  constructor() {
    this.baseUrl = process.env.NODE_ENV === 'production' 
      ? '' 
      : 'http://localhost:3001';
  }
  
  async request(endpoint, options = {}) {
    const url = \`\${this.baseUrl}/api\${endpoint}\`;
    
    const config = {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      ...options,
    };
    
    if (config.body && typeof config.body === 'object') {
      config.body = JSON.stringify(config.body);
    }
    
    const response = await fetch(url, config);
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'API ËØ∑Ê±ÇÂ§±Ë¥•');
    }
    
    return response.json();
  }
  
  // Memos API
  async getMemos() {
    return this.request('/memos');
  }
  
  async getMemo(id) {
    return this.request(\`/memos/\${id}\`);
  }
  
  async createMemo(data) {
    return this.request('/memos', {
      method: 'POST',
      body: data,
    });
  }
  
  async updateMemo(id, data) {
    return this.request(\`/memos/\${id}\`, {
      method: 'PUT',
      body: data,
    });
  }
  
  async deleteMemo(id) {
    return this.request(\`/memos/\${id}\`, {
      method: 'DELETE',
    });
  }
  
  // Health Check
  async getHealth() {
    return this.request('/health');
  }
}

export const apiClient = new NextApiClient();
export default apiClient;
`;
  
  await fs.writeFile(path.join(projectRoot, 'lib/client/apiClient.js'), clientApiContent);
  
  // Êï∞ÊçÆÊúçÂä°
  const dataServiceContent = `import { apiClient } from './apiClient.js';

class NextDataService {
  // Memos
  async getAllMemos() {
    try {
      const response = await apiClient.getMemos();
      return response.memos || [];
    } catch (error) {
      console.error('Ëé∑Âèñ memos Â§±Ë¥•:', error);
      return [];
    }
  }
  
  async getMemoById(id) {
    try {
      const response = await apiClient.getMemo(id);
      return response.memo;
    } catch (error) {
      console.error(\`Ëé∑Âèñ memo \${id} Â§±Ë¥•:\`, error);
      return null;
    }
  }
  
  async createMemo(data) {
    try {
      const response = await apiClient.createMemo(data);
      return response.memo;
    } catch (error) {
      console.error('ÂàõÂª∫ memo Â§±Ë¥•:', error);
      throw error;
    }
  }
  
  async updateMemo(id, data) {
    try {
      const response = await apiClient.updateMemo(id, data);
      return response.memo;
    } catch (error) {
      console.error(\`Êõ¥Êñ∞ memo \${id} Â§±Ë¥•:\`, error);
      throw error;
    }
  }
  
  async deleteMemo(id) {
    try {
      await apiClient.deleteMemo(id);
      return true;
    } catch (error) {
      console.error(\`Âà†Èô§ memo \${id} Â§±Ë¥•:\`, error);
      return false;
    }
  }
  
  // ÂÅ•Â∫∑Ê£ÄÊü•
  async checkHealth() {
    try {
      return await apiClient.getHealth();
    } catch (error) {
      console.error('ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•:', error);
      return { status: 'error', error: error.message };
    }
  }
}

export const dataService = new NextDataService();
export default dataService;
`;
  
  await fs.writeFile(path.join(projectRoot, 'lib/client/dataService.js'), dataServiceContent);
  
  console.log('‚úÖ ÂÆ¢Êà∑Á´ØÊúçÂä°ÂàõÂª∫ÂÆåÊàê\n');
}

/**
 * Ê≠•È™§ 8: ÂàõÂª∫ Next.js Pages
 */
async function createNextPages() {
  console.log('üìÑ ÂàõÂª∫ Next.js Pages...');
  
  // _app.js
  const appContent = `import '../src/index.css';
import { useEffect, useState } from 'react';

export default function App({ Component, pageProps }) {
  const [mounted, setMounted] = useState(false);
  
  useEffect(() => {
    setMounted(true);
  }, []);
  
  if (!mounted) {
    return null;
  }
  
  return <Component {...pageProps} />;
}
`;
  
  await fs.writeFile(path.join(projectRoot, 'pages/_app.js'), appContent);
  
  // index.js - ‰∏ªÈ°µÈù¢
  const indexContent = `import { useState, useEffect } from 'react';
import Head from 'next/head';
import { dataService } from '../lib/client/dataService.js';

export default function Home() {
  const [memos, setMemos] = useState([]);
  const [loading, setLoading] = useState(true);
  const [newMemo, setNewMemo] = useState('');
  
  useEffect(() => {
    loadMemos();
  }, []);
  
  async function loadMemos() {
    try {
      setLoading(true);
      const memosData = await dataService.getAllMemos();
      setMemos(memosData);
    } catch (error) {
      console.error('Âä†ËΩΩ memos Â§±Ë¥•:', error);
    } finally {
      setLoading(false);
    }
  }
  
  async function handleCreateMemo() {
    if (!newMemo.trim()) return;
    
    try {
      await dataService.createMemo({ 
        content: newMemo,
        tags: '',
        visibility: 'private'
      });
      setNewMemo('');
      await loadMemos();
    } catch (error) {
      console.error('ÂàõÂª∫ memo Â§±Ë¥•:', error);
      alert('ÂàõÂª∫Â§±Ë¥•: ' + error.message);
    }
  }
  
  async function handleDeleteMemo(id) {
    if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ memo ÂêóÔºü')) return;
    
    try {
      await dataService.deleteMemo(id);
      await loadMemos();
    } catch (error) {
      console.error('Âà†Èô§ memo Â§±Ë¥•:', error);
      alert('Âà†Èô§Â§±Ë¥•');
    }
  }
  
  return (
    <>
      <Head>
        <title>MeowNocode - Next.js</title>
        <meta name="description" content="MeowNocode memo app powered by Next.js" />
      </Head>
      
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
        <div className="container mx-auto px-4 py-8">
          <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-8">
            üê± MeowNocode - Next.js ÁâàÊú¨
          </h1>
          
          {/* ÂàõÂª∫Êñ∞ Memo */}
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow mb-8">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              ÂàõÂª∫Êñ∞Â§áÂøòÂΩï
            </h2>
            <div className="flex gap-4">
              <textarea
                value={newMemo}
                onChange={(e) => setNewMemo(e.target.value)}
                placeholder="ËæìÂÖ•ÊÇ®ÁöÑÂ§áÂøòÂΩïÂÜÖÂÆπ..."
                className="flex-1 p-3 border border-gray-300 dark:border-gray-600 rounded-md
                         bg-white dark:bg-gray-700 text-gray-900 dark:text-white
                         focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                rows="4"
              />
              <button
                onClick={handleCreateMemo}
                disabled={!newMemo.trim()}
                className="px-6 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600
                         disabled:opacity-50 disabled:cursor-not-allowed h-fit"
              >
                ÂàõÂª∫
              </button>
            </div>
          </div>
          
          {/* Memos ÂàóË°® */}
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              ÊàëÁöÑÂ§áÂøòÂΩï
            </h2>
            
            {loading ? (
              <div className="text-center py-8">
                <div className="animate-spin w-8 h-8 border-2 border-blue-500 border-t-transparent 
                               rounded-full mx-auto mb-4"></div>
                <p className="text-gray-600 dark:text-gray-400">Âä†ËΩΩ‰∏≠...</p>
              </div>
            ) : memos.length === 0 ? (
              <div className="text-center py-8">
                <p className="text-gray-600 dark:text-gray-400">
                  ËøòÊ≤°ÊúâÂ§áÂøòÂΩïÔºåÂàõÂª∫Á¨¨‰∏Ä‰∏™ÂêßÔºÅ
                </p>
              </div>
            ) : (
              <div className="space-y-4">
                {memos.map((memo) => (
                  <div key={memo.id} className="border border-gray-200 dark:border-gray-600 
                                               rounded-lg p-4 hover:bg-gray-50 dark:hover:bg-gray-700">
                    <div className="flex justify-between items-start">
                      <div className="flex-1">
                        <p className="text-gray-900 dark:text-white whitespace-pre-wrap">
                          {memo.content}
                        </p>
                        <div className="mt-2 text-sm text-gray-500 dark:text-gray-400">
                          ÂàõÂª∫‰∫é: {new Date(memo.created_ts).toLocaleString()}
                          {memo.updated_ts !== memo.created_ts && (
                            <span className="ml-4">
                              Êõ¥Êñ∞‰∫é: {new Date(memo.updated_ts).toLocaleString()}
                            </span>
                          )}
                        </div>
                        {memo.tags && (
                          <div className="mt-2">
                            <span className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
                              {memo.tags}
                            </span>
                          </div>
                        )}
                      </div>
                      <button
                        onClick={() => handleDeleteMemo(memo.id)}
                        className="ml-4 text-red-500 hover:text-red-700 text-sm"
                      >
                        Âà†Èô§
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
          
          {/* Áä∂ÊÄÅ‰ø°ÊÅØ */}
          <div className="mt-8 text-center text-sm text-gray-500 dark:text-gray-400">
            <p>‚úÖ Next.js ÂêéÁ´ØÂ∑≤Â∞±Áª™ - ÊîØÊåÅË∑®ÊµèËßàÂô®Êï∞ÊçÆÂÖ±‰∫´</p>
            <p>üîß ËøôÊòØ‰∏Ä‰∏™Âü∫Á°ÄÁâàÊú¨ÔºåÂÆåÊï¥ÂäüËÉΩÊ≠£Âú®ËøÅÁßª‰∏≠...</p>
          </div>
        </div>
      </div>
    </>
  );
}
`;
  
  await fs.writeFile(path.join(projectRoot, 'pages/index.js'), indexContent);
  
  console.log('‚úÖ Next.js Pages ÂàõÂª∫ÂÆåÊàê\n');
}

/**
 * ËæÖÂä©ÂáΩÊï∞ÔºöÂ§çÂà∂ÁõÆÂΩï
 */
async function copyDirectory(src, dest) {
  await fs.mkdir(dest, { recursive: true });
  
  const entries = await fs.readdir(src, { withFileTypes: true });
  
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);
    
    if (entry.isDirectory()) {
      await copyDirectory(srcPath, destPath);
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }
}

/**
 * ‰∏ªÂáΩÊï∞
 */
async function main() {
  try {
    console.log('üéØ ÂÆåÊï¥ÁöÑ Next.js ËøÅÁßªÂºÄÂßã\n');
    
    await createBackup();
    await updatePackageJson();
    await createNextConfig();
    await createNextDirectories();
    await createServerServices();
    await createApiRoutes();
    await createClientServices();
    await createNextPages();
    
    // Á°Æ‰øùÊï∞ÊçÆÁõÆÂΩïÂ≠òÂú®
    await fs.mkdir(path.join(projectRoot, 'data'), { recursive: true });
    
    console.log('üéâ ÂÆåÊï¥ÁöÑ Next.js ËøÅÁßªÂÆåÊàêÔºÅ\n');
    
    console.log('üìù ‰∏ã‰∏ÄÊ≠•Êìç‰ΩúÔºö');
    console.log('1. ËøêË°å npm install ÂÆâË£Ö‰æùËµñ');
    console.log('2. ËøêË°å npm run dev ÂêØÂä® Next.js ÂºÄÂèëÊúçÂä°Âô® (Á´ØÂè£ 3001)');
    console.log('3. ËÆøÈóÆ http://localhost:3001 Êü•Áúã Next.js ÁâàÊú¨');
    console.log('4. Âéü Vite ÁâàÊú¨‰ªçÂèØÈÄöËøá npm run dev:vite ËøêË°å (Á´ØÂè£ 8080)');
    console.log('\nüí° ÊèêÁ§∫Ôºö');
    console.log('- ÂéüÈ°πÁõÆÊñá‰ª∂Â∑≤Â§á‰ªΩÂà∞ backup-vite/ ÁõÆÂΩï');
    console.log('- ËøôÊòØÂü∫Á°ÄÁâàÊú¨ÔºåÂÆåÊï¥ UI ÂäüËÉΩÂ∞ÜÈÄêÊ≠•ËøÅÁßª');
    console.log('- Next.js ÁâàÊú¨ÊîØÊåÅË∑®ÊµèËßàÂô®Êï∞ÊçÆÂÖ±‰∫´');
    
  } catch (error) {
    console.error('‚ùå ËøÅÁßªËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØ:', error);
    process.exit(1);
  }
}

// Â¶ÇÊûúÁõ¥Êé•ËøêË°åÊ≠§ËÑöÊú¨
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export default main;